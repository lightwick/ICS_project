\documentclass{article}

%opening
\title{Simulating Different Receivers in a \\Rayleigh Fading, SISO Environment\\
\large Project \#1}
\author{Intelligent Communication Systems (ICS) Lab.\\노용재}
\date{Winter Intern Seminar (2023-1)}

\usepackage{kotex} % korean
\usepackage[margin=1in]{geometry} % 둘레 margin
\usepackage{matlab-prettifier}
\usepackage{amsmath}
\usepackage{graphicx} % image
\usepackage{subcaption} % subfigure

\newcommand{\bd}{\textbf} % bold
\providecommand{\abs}[1]{\lvert#1\rvert}
\graphicspath{{./img/}}

\begin{document}

\maketitle

모든 실험은 다음의 조건하에 진행되었다.

\begin{itemize}
  \item Es/N0는 -2dB~20dB(2dB 간격)
  \item SISO; Single Input, Single Output
\end{itemize}
\section{Binary Moduation (M=2)}
\begin{lstlisting}[style=Matlab-editor,
frame=single,
numbers=left,]
% Simulation
NumberOfSignals = 10^2;
LengthBitSequence = NumberOfSignals*log2(M); % log2(M) bits per signal

NumberIteration = 10^3;

Es = 1;

EsN0_dB = -2:2:20;
EsN0 = db2pow(EsN0_dB);

EbN0 = EsN0 / log2(M);
EbN0_dB = pow2db(EbN0);

ErrorCount_ZF = zeros(1, length(EbN0_dB));
ErrorCount_MMSE = zeros(1, length(EbN0_dB));
ErrorCount_MLD = zeros(1, length(EbN0_dB));

alphabet = qammod([0:M-1], M, 'UnitAveragePower', true);

for iTotal = 1 : NumberIteration
    
    BitSequence = randi([0 1], 1, LengthBitSequence); % Bit Generation
    SymbolSequence = qammod(BitSequence.', M, 'InputType', 'bit', 'UnitAveragePower', 1).';
    NoiseSequence = (randn(1, length(SymbolSequence)) + 1j * randn(1, length(SymbolSequence))) / sqrt(2); % Noise (n) Generation
    H = (randn(1, length(SymbolSequence)) + 1j * randn(1, length(SymbolSequence))) ./ sqrt(2); % Channel (h) Generation
    for indx_EbN0 = 1 : length(EbN0)
        ReceivedSymbolSequence = H .* SymbolSequence + NoiseSequence * sqrt(1 / EsN0(indx_EbN0)); % Received Signal (y = s + n) Generation

        % ZF Receiver
        w_zf = H.^(-1);
        DetectionSymbolSequence_ZF = ReceivedSymbolSequence .* w_zf; % Detection (Zero-Forcing: y / h)

        % MMSE Receiver
        w_mmse = (H.*conj(H)+1/EsN0(indx_EbN0)).^(-1) .* conj(H);
        z = ReceivedSymbolSequence .* w_mmse;
        arg = (ones(length(alphabet),1) * z) - (alphabet.' * H .* w_mmse);
        arg = arg .* conj(arg);
        [val,idx] = min(arg);
        DetectionSymbolSequence_MMSE = alphabet(idx);
        DetectionSymbolSequence_MMSE = z;

        % MLD Receiver
        arg = (ones(length(alphabet),1) * ReceivedSymbolSequence) - (alphabet.' * H);
        arg = abs(arg).^2;
        [val,idx] = min(arg);
        DetectionSymbolSequence_MLD = alphabet(idx);

        % Symbol Sequence -> Bit Sequence
        DetectionBitSequence_ZF = qamdemod(DetectionSymbolSequence_ZF.', M, 'OutputType', 'bit', 'UnitAveragePower', 1)';
        DetectionBitSequence_MMSE = qamdemod(DetectionSymbolSequence_MMSE.', M, 'OutputType', 'bit', 'UnitAveragePower', 1)';
        DetectionBitSequence_MLD = qamdemod(DetectionSymbolSequence_MLD.', M, 'OutputType', 'bit', 'UnitAveragePower', 1)';

        ErrorCount_ZF(1, indx_EbN0) = ErrorCount_ZF(1, indx_EbN0) + sum(DetectionBitSequence_ZF~=BitSequence);
        ErrorCount_MMSE(1, indx_EbN0) = ErrorCount_MMSE(1, indx_EbN0) + sum(DetectionBitSequence_MMSE~=BitSequence);
        ErrorCount_MLD(1, indx_EbN0) = ErrorCount_MLD(1, indx_EbN0) + sum(DetectionBitSequence_MLD~=BitSequence);
    end
end

BER_Simulation_ZF = ErrorCount_ZF / (LengthBitSequence * NumberIteration);
BER_Simulation_MMSE = ErrorCount_MMSE / (LengthBitSequence * NumberIteration);
BER_Simulation_MLD = ErrorCount_MLD / (LengthBitSequence * NumberIteration);

if M==2
    modtype='psk'
else
    modtype='qam'
end
BER_Theory = berfading(EbN0_dB, qam, M, 1);

% Plot
figure()
semilogy(EsN0_dB, BER_Theory, 'r--');
hold on
semilogy(EsN0_dB, BER_Simulation_ZF, 'bo');
semilogy(EsN0_dB, BER_Simulation_MMSE, 'bx');
semilogy(EsN0_dB, BER_Simulation_MLD, 'b^');


axis([-2 20 10^-3 0.5])
grid on
legend('Theory (Rayleigh)', 'ZF (Rayleigh)', 'MMSE (Rayleigh)', 'MLD (Rayleigh)');
xlabel('Es/No [dB]');
ylabel('BER');
title('BER for QAM (M='+string(M)+')');
\end{lstlisting}
\subsection{ZF(Zero-forcing)}
\subsection{MMSE(Minimum Mean Square Error)}
\subsection{MLD(Maximum Likelihood Detection)}
\section{M-ary QAM}
$M=2^2n$ $(n=1,2,3,...)$의 상황을 가정하였다.
한 가지 생각해볼 만한 사항은 Normalization Factor이다. 이 Normalization Factor를 사용하여 평균 전력이 1W가 되게끔 둘 수 있다.

QAM의 일반적인 Constellation Diagram을 살펴보면 실수 $\sqrt{M}$개, 허수 $\sqrt{M}$개의 point를 갖는 것을 알 수 있다.\\
하나의 지점을 하나의 alphabet이라고하자. $M$개의 alphabet은 다음과 같다.
\begin{equation}
alphabet={\pm(2n-1)\pm j\cdot(2n-1)} \qquad n\in{1,2,...,\sqrt{M}}
\end{equation}
신호의 평균전력은 다음과 같이 일반화 가능하다.
\begin{equation}
\begin{split}
E_s=E[\abs{s}^2]&=\frac{1}{M}\sum_{n=1}^M \abs{s_n}^2\\
&=\frac{1}{M}\sum_{n=1}^{\sqrt{M}} \sum_{m=1}^{\sqrt{M}} \abs{(2m-1)^2+(2n-1)^2}\\
&=\frac{1}{M}\cdot4\sum_{n=1}^\frac{\sqrt{M}}{2}\sum_{n=1}^\frac{\sqrt{M}}{2}[()]\\
&=\frac{1}{M}\cdot4\sum_{n=1}^\frac{\sqrt{M}}{2}[(2n-1)^2\cdot\sqrt{M}]\\
&=\frac{4}{M}\sum_{n=1}^\frac{\sqrt{M}}{2}[4n^2-4n+1]\\
&=\frac{2}{3}(M-1)
\end{split}
\end{equation}
(2)에서의 결과를 토대로 normalization이 이뤄진 alphabet을 구할 수 있다.
\begin{equation}
normalized\quad alphabet=\Big{[}\pm\frac{2n-1}{\sqrt{\frac{2}{3}(M-1)}}\pm j\cdot\frac{2n-1}{\sqrt{\frac{2}{3}(M-1)}}\Big{]} \qquad n\in\{1,2,...,\sqrt{M}\}
\end{equation}
해당 결과를 토대로 다시 평균 전력을 구한다면 $E_s$가 1W임을 확인할 수 있다.\\
\\
%\textit{참고자료}\\
\bd{참고자료}\\
다음은 16-QAM의 Constellation이다.\\
\begin{figure}[!ht]
	\centering
	\begin{subfigure}{0.5\textwidth}
		\centerline{\includegraphics[width=0.8\textwidth]{16qamnonunit.jpg}}
		\caption{Non-normalized Constellation}
	\end{subfigure}%
	\begin{subfigure}{0.5\textwidth}
		\centerline{\includegraphics[width=0.8\textwidth]{16qamunit.jpg}}
		\caption{Normalized Constellation}
	\end{subfigure}
	\caption{16-QAM Constellation}
\end{figure}
\\
\subsection{ZF(Zero-forcing)}
\subsection{MMSE(Minimum Mean Square Error)}
\subsection{MLD(Maximum Likelihood Detection)}
\section{과제 외적 의문점 및 질문}
\begin{itemize}
  \item 왜 $M=4$ 일때의 \textsl{BER}은 ZF와 MMSE의 경우 다르지만, $M=16$일 때는 왜 모든 값이 같은가?
  \item SNR이 얼마나 커져야 ZF와 MMSE의 \textsl{BER}이 같아질까? 수학적 공식으로 나타낼 수 있는가?
\end{itemize}
\end{document}